<!doctype html>
<notebook theme="slate">
  <title>Sauna Gamer</title>
  <script id="1" type="text/markdown">
    # Sauna Gamer
  </script>
  <script id="77" type="text/x-typescript">
    const [maxX,minX] = focus;
    const faded_str = (str) => `<span style='color: hsl(0 0 50%);'>${str}</span>`

    const filterResult = [maxX, minX].map(d => ({
          date: d,
          days_ago: d3.utcDay.count(d, update_date[0].last_update)+1,
          s_date: d3.timeFormat("%Y-%m-%d")(d),
          })).map(d => ({
          ...d,
          st: d.days_ago == 0 ? `hoje` : `${d.s_date} ${faded_str(`_(${d.days_ago} dias atrás)_`)}`
          }))
    const last_update_str = d3.timeFormat('%Y-%m-%d')(update_date[0].last_update);


    const filtrado_phrase = md`Filtrado de ${filterResult[0].st} até ${filterResult[1].st}${filterResult[0].days_ago == 0 ? '' : faded_str(`. _[${filterResult[1].days_ago - filterResult[0].days_ago} dias]_</span>`)}`;
    const last_updatePhrase = md`_Última atualização: ${last_update_str}_`

    display(html`
        <div
          style='display:flex;
                 justify-content:space-between;
                 align-items:center;
                 '>
            ${filtrado_phrase}
            ${last_updatePhrase}
        </div>`)
  </script>
  <script id="71" type="application/vnd.observable.javascript">
    viewof focus = {
      const focusHeight = 80;
      const height = 440;
      const margin = ({top: 20, right: 20, bottom: 25, left: 15});
      const margin_circles = ({bottom: 3, top: -10})

      const x = d3.scaleUtc()
        .domain([update_date[0].last_update, d3.min(sb_data, d => d.session_date)])
        .range([margin.left, width - margin.right]);

      const gdata = d3.group(sb_data.filter(f => f.session_date && f.teamPartySize >= 3), d => d.session_date);

      const y = d3.scaleLinear()
                  .domain([0, d3.max(gdata, ([sdate, g]) =>  g.length)])
                  .range([focusHeight - margin.bottom - margin_circles.bottom, margin.top + margin_circles.top])

      const xAxis = (g, x, height) => g
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));

      const svg = d3.create("svg")
        .attr("viewBox", [0, 0, width, focusHeight])
        .style("display", "block");

      const brush = d3.brushX()
          .extent([[margin.left, 0.5], [width - margin.right, focusHeight - margin.bottom + 0.5]])
          .on("brush", brushed)
          .on("end", brushended);

      const defaultSelection = [x(d3.utcDay.offset(x.domain()[0], -240)), x.range()[0]].reverse();

      svg.append("g")
          .call(xAxis, x, focusHeight);

      const sessions = svg
                    .selectAll("g.session")
                    .data(gdata)
                    .join("g")
                    .classed("session",true)
                    .attr("transform", ([sdate, obj]) => `translate(${x(sdate)},0)`);

      const matches = sessions
                        .selectAll("circle")
                        .data(([sdate, obj]) => obj)
                        .join("circle")
                          .attr("fill", d => colordomain(d.leetifyRating))
                          .attr("r", (d) => 2)
                          .attr("cx", (d) => 0)
                          .attr("cy", (d, i) => y(i));

      const gb = svg.append("g")
          .call(brush)
          .call(brush.move, defaultSelection);

      function brushed({selection}) {
        if (selection) {
          svg.property("value", selection.map(x.invert, x).map(d3.utcDay.round));
          svg.dispatch("input");
        }
      }

      function brushended({selection}) {
        if (!selection) {
          gb.call(brush.move, defaultSelection);
        }
      }

      return svg.node();
    }
  </script>
  <script id="50" type="text/markdown">
    ### Performance do time segundo o Leetify
    _Cada linha é um jogo. Quanto mais falho, mais antigo. Coloridas são o acumulado._
  </script>
  <script id="45" type="text/x-typescript">
    const gdata_per = tctdata
      // .filter(f => f.days_ago <= backwards_horizon);
      .filter(f => f.session_date <= maxX && f.session_date >= minX);

    const xdomain = [-0.10,0.10]

    const params_per = {
      general : {
        width,
        marginLeft: 80,
        marginRight: 20,
      },
      commom_marks: [
        // Plot.frame(),
        Plot.ruleX([0], {stroke: 'white', strokeDasharray: '5,5'}),
      ],
      tickX_main: {
          x: 'leetifyRating',
          opacity: d => 30/d.days_ago,
        },
      tickX_groupY_output: {
            x:'mean',
            stroke: (g) => colordomain(d3.mean(g))
          },
      tickX_groupY_input: {
          x: 'leetifyRating',
          y: 0,
          z: null,
          stroke: 'leetifyRating',
          strokeWidth: 2,
        }
    }

    const xAxis = (plot=false, anchor='bottom') => {
        const mark = Plot.axisX(d3.ticks(...xdomain, 10), {
                                                                  label: 'Leetify Rating',
                                                                  anchor
                                                                });
        if(!plot) return mark;
        return mark.plot({...params_per.general})
    }
    let test;

    // Main plot
    display(Plot.plot({
      ...params_per.general,
      marginTop: 30,
      x: {
        axis: null
        , domain: xdomain
      },
      y: {
        axis: null
      },
      marks: [
        ...params_per.commom_marks,
        Plot.tickX(gdata_per, params_per.tickX_main),
        Plot.tickX(gdata_per, Plot.groupY(params_per.tickX_groupY_output,
                                          params_per.tickX_groupY_input)),
        Plot.dot(gdata_per, Plot.groupY({x:'mean'},{
          x: 'leetifyRating',
          y: 0,
          z: null,
          dy: -50,
          opacity: 1,
          fill: d => colordomain(d.leetifyRating),
          strokeWidth: 0.5,
          stroke: 'black'
        })),
        // Plot.text(gdata_per, Plot.groupY({
        //                                   x:'mean'
        //                                  },
        //                                  {
        //   x: 'leetifyRating',
        //   y: 0,
        //   z: null,
        //   dy: -50,
        //   text: (d) => `Combinadão do time`,
        //   textAnchor: 'start',
        //   opacity: 0.5,
        //   dx: 8,
        // })),
        Plot.text(gdata_per, Plot.groupY({
                                          x:'mean',
                                          text: (g) => d3.format('.3f')(d3.mean(g))
                                         },
                                         {
          x: 'leetifyRating',
          y: 0,
          z: null,
          dy: -60,
          text: 'leetifyRating',
          frameAnchor: 'top',
          lineAnchor: 'middle',
          textWeight: 'bold'
        })),
      ]
    }))
    // By map plot
    display(Plot.plot({
      ...params_per.general,
      x: {
        domain: xdomain
      },
      y: {
        label: null,
        tickSize: 0
      },
      marks: [
        ...params_per.commom_marks,
        Plot.tickX(gdata_per, {
          ...params_per.tickX_main,
          y: 'mapName',
        }),
        Plot.tickX(gdata_per, Plot.groupY(params_per.tickX_groupY_output,
                                          {
                                            ...params_per.tickX_groupY_input,
                                            y: 'mapName',
                                            sort: {y: '-x'},
                                          })),
        xAxis()
      ]
    }))
    // display(gdata_per)
    // display(test)
  </script>
  <script id="53" type="text/markdown">
    _Performance de TR e CT separada._
  </script>
  <script id="60" type="text/x-typescript">
    const gdata_f_tct =
      gdata_per
      .map(row => {
        const {session_date, days_ago, mapName, match_id,
                tLeetifyRating, tLeetifyRatingRounds, trounds,
                ctLeetifyRating, ctLeetifyRatingRounds, ctrounds
              } =  row;

        const base = {session_date, days_ago, mapName, match_id};
        return [
          {...base, side: "TR", sideLeetifyRating: tLeetifyRating, sideRounds: trounds},
          {...base, side: "CT", sideLeetifyRating: ctLeetifyRating, sideRounds: ctrounds},
        ]
      }).flat();

    const params_f_tct = {
      general: {
        width: width,
        height: 200,
        marginLeft: 80,
        marginRight: 20,
        // insetLeft: 10,
        y: {
          label: null,
          tickSize: 0
        },
        x: {
          domain: xdomain,
          axis: null
        },
      },
      commom_marks: [
        // Plot.frame(),
        Plot.ruleX([0], {stroke: 'white', strokeDasharray: '5,5'}),
      ],
      maps_order: d3.groups(gdata_f_tct, d => d.mapName).sort((a,b) => d3.descending(a[1].length, b[1].length)).map(d => d[0])
    }

    const f_tct_plot = (height, facet) => Plot.plot({
      ...params_f_tct.general,
      ...(facet && {
        fy: {
          axis: 'left',
          label: null,
          ...(facet == 'mapName' && {domain: params_f_tct.maps_order})
        },
        y: {
          ...params_f_tct.general.y,
          axis: 'right',
          tickPadding: -25
        }
      }),
      height,
      marks: [
        ...params_f_tct.commom_marks,
        Plot.tickX(gdata_f_tct,{
          x: 'sideLeetifyRating',
          y: 'side',
          opacity: d => 30/d.days_ago,
          ...(facet && ({fy: facet}))
        }),
        Plot.tickX(gdata_f_tct,Plot.groupY({
            x:'mean',
            stroke: (g) => colordomain(d3.mean(g))
        },{
          x: 'sideLeetifyRating',
          stroke: 'sideLeetifyRating',
          y: 'side',
          strokeWidth: 2,
          ...(facet && ({fy: facet}))
        })),
        xAxis()
      ]
    })

    display(f_tct_plot(200))
    display(f_tct_plot(params_f_tct.maps_order.length * 100,'mapName'))

    // display(gdata_f_tct)
  </script>
  <script id="49" type="text/markdown">
    ### O resto tá inacabado, e serve como laboratório
    Pode ignorar
  </script>
  <script id="42" type="application/sql" database="cs2teamdedication" output="tctdata">
    with team_matches as (
      select
        session_date
        , match_id
        , mapName
        , initialTeamNumber
        , matchResult
        , rounds
        , tLeetifyRatingRounds as trounds
        , ctLeetifyRatingRounds as ctrounds
        , tRoundsWon as trounds_won
        , ctRoundsWon as ctrounds_won
        -- , sum(case when matchResult = 'win' then 1 else 0 end) as wins
        -- , sum(case when matchResult = 'loss' then 1 else 0 end) as losses
        -- , sum(case when matchResult = 'draw' then 1 else 0 end) as draws
        , avg(leetifyRating) as leetifyRating
        , avg(tLeetifyRating) as tLeetifyRating
        , avg(ctLeetifyRating) as ctLeetifyRating
      from
        player_matches
      where
        teamPartySize >= 3
      group by
        1,2,3,4,5,6,7,8,9,10
    )
    select
      *,
      date_diff('day', session_date, current_date) as days_ago
    from
      team_matches
  </script>
  <script id="69" type="application/sql" database="cs2teamdedication" output="sb_data">
    with team_matches as (
      select
        session_date
        , match_id
        , mapName
        , initialTeamNumber
        , matchResult
        , rounds
        , tLeetifyRatingRounds as trounds
        , ctLeetifyRatingRounds as ctrounds
        , tRoundsWon as trounds_won
        , ctRoundsWon as ctrounds_won
        , teamPartySize
        , avg(leetifyRating) as leetifyRating
      from
        player_matches
      group by
        1,2,3,4,5,6,7,8,9,10,11
    )
    select
      *,
      date_diff('day', session_date, current_date) as days_ago
    from
      team_matches
    where
      session_date > '2021-08-30'
    order by 1 asc
  </script>
  <script id="34" type="text/x-typescript">
    const hePlot = Plot.plot({
      width,
      marginLeft: 120,
      height: 1200,
      fy: {
        label: null
      },
      x : {
        type: 'time',
        domain: [d3.max(ffdata, d => d.session_date),d3.timeDay.offset(d3.max(ffdata, d => d.session_date),-200)],
        grid: true
      },
      marks: [
        Plot.dot(ffdata,
        Plot.dodgeY({
          fy: 'name',
          r: d => d.totalHEdamage,
          x: 'session_date',
          fill: 'heThrown',
          anchor: 'middle',
          tip:true
        }))
      ]
    })
    display(md`nada a ver por enquanto`)
  </script>
  <script id="33" type="application/sql" database="cs2teamdedication" output="ffdata">
    select
      name, session_date
      , count(*) as games
      , sum(rounds) as total_rounds
      , sum(heThrown) as heThrown
      , sum(heThrown * heFriendsDamageAvg) as totalHEdamage
      , sum(flashbangThrown) as flashbangThrown
      , sum(flashbangHitFriend) as flashbangHitFriend
      , sum(shotsHitFriend) as shotsHitFriend
    from
      player_matches pm
      left join profiles p on pm.profile_id = p.profile_id
    where
      teamPartySize >= 3
    group by 1,2
      order by 2 desc, 1
    -- limit 10
  </script>
  <script id="32" type="text/markdown">
    Falei pra ignorar rapá
  </script>
  <script id="24" type="text/x-typescript">
    const sample_profiles = profilessample.map(p => ({
      ...p
      , recentRatings: JSON.parse(p.recentRatings)
      , personalBestsCS2: JSON.parse(p.personalBestsCS2)
      , json: JSON.parse(p.raw_json)
    }))
    const sample_matches = matchessample.map(m => ({...m, json: JSON.parse(m.raw_json)}))
    const sample_playermatches = playermatchessample

    display({
      sample_profiles,
      sample_matches,
      sample_playermatches
    })
  </script>
  <script id="78" type="text/x-typescript" pinned="">
    const colordomain = d3.scaleSequential(d3.interpolateRdYlGn).domain([-0.05,0.05])
  </script>
  <script id="2" type="application/sql" database="cs2teamdedication" output="profilessample">
    select * from profiles where profile_id = '76561198056952889' limit 1
  </script>
  <script id="4" type="application/sql" database="cs2teamdedication" output="matchessample">
    select * from matches where match_id = '5443c096-fb59-4f71-b1c9-4750a81ba8b2' limit 1
  </script>
  <script id="31" type="application/sql" database="cs2teamdedication" output="playermatchessample">
    select * from player_matches
      where match_id = '5443c096-fb59-4f71-b1c9-4750a81ba8b2'
    limit 10
  </script>
  <script id="54" type="application/sql" database="cs2teamdedication" output="update_date">
    LOAD icu;
    SET TimeZone = 'America/Sao_Paulo';
    select current_timestamp as last_update
  </script>
</notebook>
